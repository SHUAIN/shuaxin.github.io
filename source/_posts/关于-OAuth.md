---
title: 关于-OAuth
category:
  - 技术笔记
date: 2022-02-22 09:18:38
tag:
 - Github
 - OAuth
index_img: http://img.shuaxinjs.cn/lglFcriXMY77ziSt1EcwcUoCB_7B.jpeg
banner_img: http://img.shuaxinjs.cn/lglFcriXMY77ziSt1EcwcUoCB_7B.jpeg
---

> [壁纸出处](https://www.zfrontier.com/app/flow/45MLjxYGzzQ9)

最近在做一个小玩具，需要调github的api，然后了解到了oauth，记录一下..

# 是什么

- 用于 *资源提供方* 给 *第三方* 授权允许他们一定程度访问自己资源的一种 *授权机制* ，目前最新的事 OAuth 2.0
- 一般就是第三方插件用一些官方api做一些官方没有提供的功能

# 工作流程

- 第三方去资源提供方注册，资源方会提供一个客户端秘钥（client_secret）和客户端id（client_id）
- 当用户要授权访问的资源方给第三方时，第三方会携带步骤一的秘钥以及id去请求资源方的授权url，验证无误后，会跳回注册时的回调url，并携带一个授权凭证（code）
- 第三方拿到该code后，去请求获取令牌（token）的接口，这时就会返回可以有效访问资源方资源的令牌，之后所有请求在 *header* 的 authorization 携带拿到的token即可

# 为什么

> 安全

- 用户不需要将自己的账号密码告诉第三方，不用担心密码泄露造成其他影响

> 易控

- 权限和范围和有效期的控制，只需要让令牌失效和针对注册的应用做限制即可

> 独立

- 每个第三方应用不依赖用户账号密码，即使账号密码发生变动，只要资源方提供的令牌不失效就不会有影响
- eg:如果是通过账号密码来授权，当用户改了密码后，就需要给每个第三方重新授权

# 使用场景

- 常见于各平台（github、微博等）的open api的身份验证

# 实现方式

除过上述的这种方式（授权式）外，还有几种授权的方式，详见[OAuth2.0标准文件 - RFC 6749 ](https://datatracker.ietf.org/doc/html/rfc6749)：

- 隐藏式：在上述步骤的申请授权码（code）的步骤中，直接返回令牌（token），这样可以在一些无server端的场景使用
- 密码式：直接授权第三方获取自己账号密码（不推荐），但是部分场景可能第三方资源厂商控制获取资源的方式可能会更严，这时候就需要这样（一些第三方客户端：微博、Twitter等）
- 凭证式：在请求授权码的过程中携带客户端id和秘钥，不会跳转url，直接返回令牌，在一些命令行场景使用

# 总结

*OAuth* 相当于在登录系统之外加了一层 *授权层*，通过这一层来区分真正的用户和第三方
